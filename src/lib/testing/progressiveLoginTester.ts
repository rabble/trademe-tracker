/**
 * Progressive Login Testing Utilities
 * 
 * This module provides tools for testing the progressive login system,
 * including simulating edge cases, cross-device scenarios, and
 * performing security and performance checks.
 */

import { 
  getTempUserId, 
  clearTempUserId, 
  storeTempUserId,
  generateTempUserId
} from '../tempUserManager';
import { supabase } from '../supabase';

/**
 * Test cookie and localStorage access/fallbacks
 * @returns Object with test results
 */
export const testStorageMechanisms = async (): Promise<{
  cookiesEnabled: boolean;
  localStorageEnabled: boolean;
  fallbackWorking: boolean;
  storageSize: number;
}> => {
  // Clear any existing temp user first
  clearTempUserId();
  
  // Check if cookies are enabled
  const cookiesEnabled = navigator.cookieEnabled;
  
  // Check if localStorage is available
  let localStorageEnabled = false;
  try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
    localStorageEnabled = true;
  } catch (e) {
    localStorageEnabled = false;
  }
  
  // Test fallback mechanism
  let fallbackWorking = false;
  
  // If cookies are disabled but localStorage works, test the fallback
  if (!cookiesEnabled && localStorageEnabled) {
    const testId = generateTempUserId();
    try {
      // Store directly in localStorage
      localStorage.setItem('mivoy_temp_user_id', testId);
      
      // Try to get through the manager
      const retrievedId = getTempUserId();
      
      // Check if fallback worked
      fallbackWorking = retrievedId === testId;
      
      // Clean up
      localStorage.removeItem('mivoy_temp_user_id');
    } catch (e) {
      fallbackWorking = false;
    }
  }
  
  // Calculate storage size
  const testId = generateTempUserId();
  storeTempUserId(testId);
  
  // Get cookie size (approximate)
  const cookies = document.cookie;
  const cookieSize = cookies.length;
  
  // Get localStorage size
  const localStorageSize = localStorage.getItem('mivoy_temp_user_id')?.length || 0;
  
  // Total size
  const storageSize = cookieSize + localStorageSize;
  
  // Clean up
  clearTempUserId();
  
  return {
    cookiesEnabled,
    localStorageEnabled,
    fallbackWorking,
    storageSize
  };
};

/**
 * Simulate cross-device scenario by exporting and importing temp user data
 * @returns Export string that can be used to import the data on another device
 */
export const exportTempUserData = async (): Promise<string> => {
  const tempUserId = getTempUserId();
  
  if (!tempUserId) {
    throw new Error('No temporary user ID found to export');
  }
  
  try {
    // Get all pins for the temp user
    const { data: pins } = await supabase
      .from('property_pins')
      .select('*')
      .eq('temp_user_id', tempUserId);
    
    // Get all collections for the temp user
    const { data: collections } = await supabase
      .from('property_collections')
      .select('*')
      .eq('temp_user_id', tempUserId);
    
    // Create export package
    const exportData = {
      tempUserId,
      timestamp: new Date().toISOString(),
      pins: pins || [],
      collections: collections || [],
    };
    
    // Convert to string and encode
    return btoa(JSON.stringify(exportData));
  } catch (error) {
    console.error('Error exporting temp user data:', error);
    throw error;
  }
};

/**
 * Import temporary user data from an export string
 * @param exportString The string generated by exportTempUserData
 * @returns Success status and summary of imported data
 */
export const importTempUserData = async (exportString: string): Promise<{
  success: boolean;
  summary: {
    importedPins: number;
    importedCollections: number;
  };
}> => {
  try {
    // Decode and parse the export data
    const exportData = JSON.parse(atob(exportString));
    
    // Generate a new temporary user ID for this device
    const newTempUserId = generateTempUserId();
    storeTempUserId(newTempUserId);
    
    // Register the new temp user in the database
    const { error: registerError } = await supabase
      .from('temp_users')
      .insert({ id: newTempUserId });
    
    if (registerError) {
      throw registerError;
    }
    
    // Import pins
    let importedPins = 0;
    if (exportData.pins && exportData.pins.length > 0) {
      // Transform pins to use the new temp user ID
      const pinsToImport = exportData.pins.map((pin: any) => ({
        property_id: pin.property_id,
        temp_user_id: newTempUserId,
        collection_id: pin.collection_id,
        notes: pin.notes
      }));
      
      // Insert pins
      const { data: insertedPins, error: pinsError } = await supabase
        .from('property_pins')
        .insert(pinsToImport)
        .select();
      
      if (pinsError) {
        throw pinsError;
      }
      
      importedPins = insertedPins?.length || 0;
    }
    
    // Import collections
    let importedCollections = 0;
    if (exportData.collections && exportData.collections.length > 0) {
      // Transform collections to use the new temp user ID
      const collectionsToImport = exportData.collections.map((collection: any) => ({
        name: collection.name,
        description: collection.description,
        temp_user_id: newTempUserId
      }));
      
      // Insert collections
      const { data: insertedCollections, error: collectionsError } = await supabase
        .from('property_collections')
        .insert(collectionsToImport)
        .select();
      
      if (collectionsError) {
        throw collectionsError;
      }
      
      importedCollections = insertedCollections?.length || 0;
    }
    
    return {
      success: true,
      summary: {
        importedPins,
        importedCollections
      }
    };
  } catch (error) {
    console.error('Error importing temp user data:', error);
    return {
      success: false,
      summary: {
        importedPins: 0,
        importedCollections: 0
      }
    };
  }
};

/**
 * Test security of the temporary user system
 * @returns Object with security test results
 */
export const testTemporaryUserSecurity = async (): Promise<{
  cookieSecure: boolean;
  idFormatValid: boolean;
  rlsPoliciesWorking: boolean | undefined;
}> => {
  // Generate and store a test ID
  const testId = generateTempUserId();
  storeTempUserId(testId);
  
  // Check if cookies are secure
  let cookieSecure = false;
  const cookies = document.cookie;
  cookieSecure = !cookies.includes('mivoy_temp_user_id=') || cookies.includes('Secure');
  
  // Check ID format validity
  const retrievedId = getTempUserId();
  const idFormatValid: boolean = 
    (retrievedId?.startsWith('temp_') && 
    retrievedId?.length > 40 && 
    retrievedId === testId) ? true : false;
  
  // Test RLS policies
  let rlsPoliciesWorking: boolean = false;
  
  try {
    // Try to access a different temp user's data
    const fakeId = 'temp_fake_' + Math.random().toString(36).substring(2);
    
    // Set the correct temp user ID for RLS
    await supabase.rpc('set_temp_user_id', { p_temp_user_id: testId });
    
    // Try to query pins for a different temp user
    const { data, error } = await supabase
      .from('property_pins')
      .select('*')
      .eq('temp_user_id', fakeId);
    
    // If this returns data for the fake ID or fails with permission error, RLS is working
    // Successful queries with no results are expected (empty array)
    rlsPoliciesWorking = (!error && Array.isArray(data) && data.length === 0) ? true : false;
  } catch (error) {
    console.error('Error testing RLS policies:', error);
    rlsPoliciesWorking = false;
  }
  
  // Clean up
  clearTempUserId();
  
  return {
    cookieSecure: cookieSecure,
    idFormatValid: idFormatValid,
    rlsPoliciesWorking: rlsPoliciesWorking
  };
};

/**
 * Test performance of the temporary user system
 * @returns Object with performance test results
 */
export const testPerformance = async (): Promise<{
  storageSizeKb: number;
  idGenerationTimeMs: number;
  mergeTimeEstimateMs: number;
}> => {
  // Clear any existing temp user
  clearTempUserId();
  
  // Measure ID generation time
  const startGeneration = performance.now();
  const testId = generateTempUserId();
  const endGeneration = performance.now();
  const idGenerationTimeMs = endGeneration - startGeneration;
  
  // Store ID and measure size
  storeTempUserId(testId);
  const cookiesSize = document.cookie.length;
  const localStorageSize = JSON.stringify(localStorage).length;
  const storageSizeKb = (cookiesSize + localStorageSize) / 1024;
  
  // Estimate merge time based on sample operations
  const startMerge = performance.now();
  
  // Simulate operations in merge process
  // 1. Database fetch
  await supabase.from('temp_users').select('*').eq('id', testId);
  
  // 2. Database updates (simulated)
  await new Promise(resolve => setTimeout(resolve, 50));
  
  const endMerge = performance.now();
  const mergeTimeEstimateMs = endMerge - startMerge;
  
  // Clean up
  clearTempUserId();
  
  return {
    storageSizeKb,
    idGenerationTimeMs,
    mergeTimeEstimateMs
  };
};

/**
 * Run a complete test suite for the progressive login system
 * @returns Object with all test results
 */
export const runTestSuite = async (): Promise<{
  storage: Awaited<ReturnType<typeof testStorageMechanisms>>;
  security: Awaited<ReturnType<typeof testTemporaryUserSecurity>>;
  performance: Awaited<ReturnType<typeof testPerformance>>;
  crossDeviceReady: boolean;
}> => {
  try {
    const storage = await testStorageMechanisms();
    const security = await testTemporaryUserSecurity();
    const performance = await testPerformance();
    
    // Check if cross-device functionality is ready
    const crossDeviceReady: boolean = 
      storage.cookiesEnabled || (storage.localStorageEnabled && storage.fallbackWorking ? true : false);
    
    return {
      storage,
      security,
      performance,
      crossDeviceReady
    };
  } catch (error) {
    console.error('Error running test suite:', error);
    throw error;
  }
};